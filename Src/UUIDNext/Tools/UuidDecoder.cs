using System.Buffers.Binary;

namespace UUIDNext.Tools;

/// <summary>
/// Provite a set of static methods for decoding UUIDs
/// </summary>
public static class UuidDecoder
{
    private static readonly DateTime GregorianCalendarStart = new(1582, 10, 15, 0, 0, 0, DateTimeKind.Utc);
    private static readonly DateTime Epoch = new(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
    private static readonly DateTime JanuaryFirst2020 = new(2020, 1, 1, 0, 0, 0, DateTimeKind.Utc);
    private static readonly DateTime JanuaryFirst2100 = new(2100, 1, 1, 0, 0, 0, DateTimeKind.Utc);

    /// <summary>
    /// Returns the version of the UUID
    /// </summary>
    public static int GetVersion(Guid guid)
    {
        Span<byte> bytes = stackalloc byte[16];
        guid.TryWriteBytes(bytes, bigEndian: true, out var _);
        return GetVersion(bytes);
    }

    /// <summary>
    /// Try to retrieve the Unix timestamp from a Guid.
    /// Currently work for UUIDv6, UUIDv7 and UUIDv8 (if the UUIDv8 is a sequential UUID for SQL Server)
    /// </summary>
    public static bool TryDecodeTimestamp(Guid guid, out DateTime date)
    {
        Span<byte> bytes = stackalloc byte[16];
        guid.TryWriteBytes(bytes, bigEndian: true, out var _);

        long timestamp;

        var version = GetVersion(bytes);
        switch (version)
        {
            case 6:
                // UUID v6 and v1 use a timestamp based on the start of the gregorian calendar (see RFC 9562 - Section 5.1)
                var v6Timestamp = GetUuidV6TimestampInTicksFromGegorianCalendar(bytes);
                date = GregorianCalendarStart.AddTicks(v6Timestamp);
                return true;
            case 7:
                timestamp = readTimestamp(bytes, 0);
                date = Epoch.AddMilliseconds(timestamp);
                return true;
            case 8:
                timestamp = readTimestamp(bytes, 10);
                // UUIDs generated by UuidV8SqlServerGenerator use the current date for the timestamp 
                // so we check if the decoded timestamp correspond to a reasonable date.
                // if not, that means that it's not a UUID generated by UuidV8SqlServerGenerator
                // If you're the person debugging that code in the year 2100, hello from the past
                // and sorry for that, I didn't think that my code would live so long
                // If the person debugging that code is ME, congratulation for living so long ! You're about to beat Jeanne Calment !
                date = Epoch.AddMilliseconds(timestamp);
                return JanuaryFirst2020 < date && date < JanuaryFirst2100;
            default:
                date = default;
                return false;
        }
    }

    /// <summary>
    /// Returns the timestamp and the sequence number of a UUID version 7
    /// </summary>
    public static (long timestampMs, short sequence) DecodeUuidV7(Guid guid)
    {
        Span<byte> bytes = stackalloc byte[16];
        guid.TryWriteBytes(bytes, bigEndian: true, out var _);

        long timestampMs = readTimestamp(bytes, 0);

        var sequenceBytes = bytes.Slice(6, 2);
        //remove version information
        sequenceBytes[0] &= 0b0000_1111;
        short sequence = BinaryPrimitives.ReadInt16BigEndian(sequenceBytes);

        return (timestampMs, sequence);
    }

    /// <summary>
    /// Returns the timestamp and the sequence number of a UUID version 8 for SQL Server
    /// </summary>
    public static (long timestampMs, short sequence) DecodeUuidV8ForSqlServer(Guid guid)
    {
        Span<byte> bytes = stackalloc byte[16];
        guid.TryWriteBytes(bytes, bigEndian: true, out var _);

        long timestampMs = readTimestamp(bytes, 10);

        var sequenceBytes = bytes.Slice(8, 2);
        //remove variant information
        sequenceBytes[0] &= 0b0011_1111;
        short sequence = BinaryPrimitives.ReadInt16BigEndian(sequenceBytes);

        return (timestampMs, sequence);
    }

    private static int GetVersion(Span<byte> uuidBytes) => uuidBytes[6] >> 4;

    private static long readTimestamp(Span<byte> bytes, int timestampStart)
    {
        Span<byte> timestampBytes = stackalloc byte[8];
        bytes.Slice(timestampStart, 6).CopyTo(timestampBytes.Slice(2, 6));
        return BinaryPrimitives.ReadInt64BigEndian(timestampBytes);
    }

    private static long GetUuidV6TimestampInTicksFromGegorianCalendar(Span<byte> uuidBytes)
    {
        var timestampBytes = uuidBytes.Slice(0, 8);
        //remove version information
        timestampBytes[6] = (byte)((timestampBytes[6] << 4) | (timestampBytes[7] >> 4));
        timestampBytes[7] = (byte)(timestampBytes[7] << 4);
        return BinaryPrimitives.ReadInt64BigEndian(timestampBytes) >> 4;
    }
}
